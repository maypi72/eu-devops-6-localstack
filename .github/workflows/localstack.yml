name: localstack

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

# Evitar solapamiento
concurrency:
  group: localstack-${{ github.ref }}
  cancel-in-progress: true

# Permisos mínimos del workflow
permissions:
  contents: read

jobs:
  up-localstack:
    runs-on: [self-hosted, Linux]

    env:
      # Credenciales para Localstack (requeridas por AWS CLI)
      AWS_ACCESS_KEY_ID: ${{AWS_ACCESS_KEY_ID}}
      AWS_SECRET_ACCESS_KEY: ${{AWS_SECRET_ACCESS_KEY}}
      AWS_DEFAULT_REGION: eu-west-1
      LOCALSTACK_HOST: localhost
      LOCALSTACK_ENDPOINT: http://localhost:4566
      # Tiempo de espera
      LOCALSTACK_WAIT_SECONDS: "60"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Mostrar versiones Docker y plugin compose
        run: |
          docker --version
          docker compose version

      # LIMPIEZA completa: contenedores + volúmenes
      - name: Parar contenedores si existen (limpieza completa)
        run: docker compose down -v || true

      - name: Pull de imágenes (última versión)
        run: docker compose pull

      - name: Start Localstack (docker-compose)
        run: docker compose up -d

      # Espera activa establecida para esperar a que levante localstack
      - name: Wait for Localstack (short sleep)
        run: |
          echo "Waiting ${LOCALSTACK_WAIT_SECONDS}s for Localstack to be ready..."
          sleep "${LOCALSTACK_WAIT_SECONDS}"
     
      - name: Verificar si los scripts existen y son ejecutables
        run: |
          test -f localstack-init/01-create-resources.sh || { echo "Falta localstack-init/01-create-resources.sh"; exit 1; }
          test -f localstack-init/02-insert-sample-data.sh || { echo "Falta localstack-init/02-insert-sample-data.sh"; exit 1; }
          chmod +x localstack-init/01-create-resources.sh
          chmod +x localstack-init/02-insert-sample-data.sh

      # Exportar variables para que los scripts puedan usar AWS CLI contra Localstack
      - name: Create AWS resources (buckets, tables, queues, logs)
        env:
          AWS_ACCESS_KEY_ID: ${{ env.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ env.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_DEFAULT_REGION }}
          LOCALSTACK_ENDPOINT: ${{ env.LOCALSTACK_ENDPOINT }}
        run: ./localstack-init/01-create-resources.sh

      - name: Insert sample data
        env:
          AWS_ACCESS_KEY_ID: ${{ env.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ env.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_DEFAULT_REGION }}
          LOCALSTACK_ENDPOINT: ${{ env.LOCALSTACK_ENDPOINT }}
        run: ./localstack-init/02-insert-sample-data.sh

      # --- Verificaciones ---
      # Preferencia: awslocal. Si no existe, fallback a aws --endpoint-url.
      - name: Verify S3 buckets
        run: |
          if command -v awslocal >/dev/null 2>&1; then
            awslocal s3 ls
          else
            aws --endpoint-url "${LOCALSTACK_ENDPOINT}" s3 ls
          fi

      - name: Verify DynamoDB tables
        run: |
          if command -v awslocal >/dev/null 2>&1; then
            awslocal dynamodb list-tables
          else
            aws --endpoint-url "${LOCALSTACK_ENDPOINT}" dynamodb list-tables
          fi

      - name: Verify SQS queues
        run: |
          if command -v awslocal >/dev/null 2>&1; then
            awslocal sqs list-queues || echo "No queues returned (could be empty)"
          else
            aws --endpoint-url "${LOCALSTACK_ENDPOINT}" sqs list-queues || echo "No queues returned (could be empty)"
          fi

      - name: Verify CloudWatch Log Groups
        run: |
          echo "Checking CloudWatch log groups..."
          if command -v awslocal >/dev/null 2>&1; then
            awslocal logs describe-log-groups --log-group-name-prefix /la-huella/
          else
            aws --endpoint-url "${LOCALSTACK_ENDPOINT}" logs describe-log-groups --log-group-name-prefix /la-huella/
          fi

